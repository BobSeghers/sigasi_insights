---
title: "Recovering VHDL Parser"
layout: page 
pager: true
author: philippe.faes (Sigasi)
date: 2012-09-21
tags: 
  - recovering VHDL parser
  - VHDL compiler
  - VHDL Parser
---
<div class="content">
<p>It is useful to analyze code that is only partly finished, code that still has errors in it. Analyzing broken code helps people understand, improve and complete the code. In order to perform such an analysis, you need a parser that recovers after it encounters an error. In the world of hardware design, hardly any recovering parsers exist and engineers are left out in the cold. All but a few <span class="caps">EDA</span> tools fail miserably at parsing incorrect <span class="caps">VHDL</span> code.</p>	<h2>Your code is (almost) never correct</h2>	<p>When you write <span class="caps">VHDL</span> code, it is broken 99% of the time. While you are adding or removing code, while you are typing new statements your code is not syntactically correct. Only when you save and press compile, your <span class="caps">VHDL</span> code is correct (or so you hope). This means that traditional parsers are useless for your code <em>most</em> of the time.</p>	<h2>Why compile broken <span class="caps">VHDL</span> code?</h2>	<p>There are two use cases why you would want to compile incomplete or broken code. First (as I've just mentioned), you can compile code while you are still working on it. This is useful because it allows you to use a wide range of features without having to bring your code to a "correct" state. You can navigate to declaration, hover to see extra information, have semantic highlighting, autocomplete record fields, see a file outline and chip hierarchy and much more. </p>	<p>Second, if you dig up an old project (for bug fixing or for reusing <span class="caps">VHDL</span> code), chances are that you can't get it to compile right away. Even if your team always stores projects with perfect build scripts, you may inherit a project from another team that does not adhere to the same standards. </p>	<p>In order to compile broken code, the parser needs to recover from any error in the code. Building a recovering parser is not easy, but it is doable. I'm proud to say that Sigasi probably has the best recovering capabilities of any <span class="caps">VHDL</span> parser in the market.</p>	<h2>Parsers are optimized for correct code only</h2>	<p>Traditional parser technology deals with the problem of analyzing a sequence of tokens determining the structure of these tokens with regards to a formal grammar, often expressed as <a href="http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form" class="elf-external elf-icon"><span class="caps">BNF</span></a>. Parsers have been built and optimized to deal with more complex grammers, with larger files and in less time with less memory. Traditional <span class="caps">VHDL</span> parsers also assume that the code is correct and ready to be compiled. That is a false assumption. These parsers cannot process your <span class="caps">VHDL</span> code 99% of the time. </p>	<h2>Traditional <span class="caps">VHDL</span> parsers and broken code</h2>	<p>Traditional <span class="caps">VHDL</span> parsers, based on parser generators like <a href="http://nl.wikipedia.org/wiki/Yacc" class="elf-external elf-icon">Lex/Yacc</a>, do not handle broken code well at all. In some cases a single error will trigger <a href="/content/one-misstake-one-error-marker">way too many error messages</a>. In other cases, traditional <a href="/content/three-misstakes-three-error-markers"><span class="caps">VHDL</span> parsers bail out after a single error</a> and ignore warnings further down in the file.</p>	<p>Non-recovering parsers are an artifact of history. All new computer languages are created with modern and better parsers, with better error recovery and more sensible error messages. Sadly, most <span class="caps">EDA</span> companies still use parsers technology from three decades ago.</p>  <div id="book-navigation-1518" class="book-navigation">    <ul class="menu"><li class="leaf first"><a href="/content/one-mistake-one-error-marker">One mistake, one error marker</a></li><li class="leaf last"><a href="/content/three-mistakes-three-error-markers">Three mistakes, three error markers</a></li></ul>        <div class="page-links clear-block">              <a href="/content/open-declaration" class="page-previous" title="Go to previous page">&#8249; Open Declaration</a>                    <a href="/knowledge-base" class="page-up" title="Go to parent page">up</a>                    <a href="/content/one-mistake-one-error-marker" class="page-next" title="Go to next page">One mistake, one error marker &#8250;</a>          </div>      </div>  </div>

