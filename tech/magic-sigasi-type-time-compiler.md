---
title: "The magic of Sigasi's type-time compiler. Part 1: Models"
layout: page 
pager: true
author: heeckhau (Sigasi)
date: 2011-12-22
tags: 
  - hdt-2.0
  - Sigasi
---
<div class="content">
<p><em>How does your Sigasi editor gather all <strong>information</strong> on your projects to enable features like navigation, outline, hovering, linting, refactorings &#8230;? And how did they make it so <strong>fast</strong> that it works while you type? And how does Sigasi keeps its <strong>memory</strong> footprint under control?</em></p>	<p>This blog post tries to shed some light on the apparent magic behind Sigasi 2.x. In this blog I explain Sigasi's <em>datastructures</em>. A follow-up blog will explain how these datastructures are built. This should make you understand what the messages in the progress view mean. This will help you better understand what is going on.</p>	<p>Sigasi builds a <em>Model</em> --an internal representation-- of your project, and it updates and refines this Model while processing your <span class="caps">VHDL</span> files. The Model is a structured, high level representation of your <span class="caps">VHDL</span> code. It serves as input for all of Sigasi's features: Autocomplete, Open Declaration, Format &#8230; Whenever you change your code, the Model changes too. And all individual features are notified of these changes.</p>	<p>The complete Model of large <span class="caps">VHDL</span> projects can be very large.  A rule of thumb for the size of the complete Model is to multiply the size of the original <span class="caps">VHDL</span> source by a factor of 60.  To keep memory usage under control, the Model is, at any time, only partially loaded in memory at any time. <br/>Sigasi divides the Model in three layers of detail. A <strong>Global Index</strong> (for the entire work space), a <strong>Meta Model</strong> (for each file) and a <strong>Text Model</strong> (for each file):	</p><ul><li>The <strong>Global Index</strong> contains the description of the globally visible <span class="caps">VHDL</span> objects such as entities and packages. This information is kept permanently in memory.</li>		<li>The <strong>Meta Model</strong> is a high level Model of your parsed design files. It contains the description of your files represented as a tree of <span class="caps">VHDL</span> constructs (e.g., design units containing architectures containing concurrent statements &#8230;).</li>		<li>The <strong>Text Model</strong> links the meta Model to the original <span class="caps">VHDL</span> text. This Model contains all the specifics of your code to lowest level of details (e.g. whitespace etc.).</li>	</ul><p>Sigasi loads only the required level of detail. If no files are open, Sigasi only loads the Global Index. When you edit a file, everything about that file is loaded. Sigasi also loads the Meta Model of the dependencies of that file. For instance, if a package in another file declares a data type and the file in your editor file refers to this data type, we also need the Meta Model of the file containing this package. The Meta Model provides information for features such as semantic highlighting and linting. If it is not strictly necessary to load the Meta Model for a given file, Sigasi only loads the Global Index, which is a much smaller data structure than the Meta Model.</p>	<p>Hendrik.</p>	<p><strong>Update:</strong> Learn more in <a href="/content/understanding-sigasi-progress-bar">part 2 of this post</a> which deals with how the progress bar works.</p>  </div>

